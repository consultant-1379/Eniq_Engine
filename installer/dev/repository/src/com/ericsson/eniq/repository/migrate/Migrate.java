package com.ericsson.eniq.repository.migrate;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.Driver;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

/**
 * This Class is responsible for Migrating the data from Sybase IQ to SQL Anywhere (ASA). 
 * It is used when upgrading from all releases prior to ENIQ 11.2.8. 
 * This Class UNLOADs all the tables from the old repdb (Catalog store in Sybase IQ) 
 * and LOADs them into the new repdb (SQL Anywhere, ASA).
 * @author eeikbe
 *
 */

public class Migrate {
    private static String dbURL       = System.getProperty("dbUrl", "jdbc:sybase:Tds:repdb:2641");
    private static String dbType      = System.getProperty("dbType", "sybase"); 
    private static String driverName  = System.getProperty("driverName", "com.sybase.jdbc3.jdbc.SybDriver");
    private static String strUserName = System.getProperty("strUserName", "DBA"); 
    private static String strPassword = System.getProperty("strPassword", "sql");
    private static String conName     = "Migration";
    private static boolean autoCommit = true;
    private static int tableCount     = 0;  //NOPMD //used for logging the number of tables.
    private static Connection connection = null; //NOPMD
    
    private static final String UNLOAD = "UNLOAD TABLE ";
    private static final String LOAD   = "LOAD TABLE ";
    private static final String TO     = " TO "; //NOPMD
    private static final String FROM   = " FROM ";
	private static final String loadTableStatementsFileName = "loadTableStatements.sql";
    
    private static Logger logger = Logger.getLogger("com.ericsson.eniq.repository.migrate");
    


    public Migrate(){
    	//Default Constructor.
    }

	/**
	 * @param VM arguments.
	 * <table border=1>
	 * <cpation>Required parameters and their default values</caption>
	 * <thead>
	 * <tr>
	 * <th>Name</th>
	 * <th>Default Value</th>
	 * <th>Description</th>
	 * </tr>
	 * </thead>
	 * <tbody>
	 *    <tr>
	 *       <td>dbUrl</td>
	 *       <td>jdbc:sybase:Tds:repdb:2641</td>
	 *       <td>URL of the repdb database</td>
	 *    </tr>
	 *    <tr>
	 *       <td>dbType</td>
	 *       <td>sybase</td>
	 *       <td>Type of the database</td>
	 *    </tr>
	 *    <tr>
	 *       <td>driverName</td>
	 *       <td>com.sybase.jdbc3.jdbc.SybDriver</td>
	 *       <td>Name of the Dirver used to connect to the database</td>
	 *    </tr>
	 *    <tr>
	 *       <td>strUserName</td>
	 *       <td>DBA</td>
	 *       <td>User name to connect to the database with</td>
	 *    </tr>
	 *    <tr>
	 *       <td>strPassword</td>
	 *       <td>sql</td>
	 *       <td>Password of strUserName</td>
	 *    </tr>
	 *    <tr>
	 *       <td>migrationType</td>
	 *       <td>update</td>
	 *       <td>This tells the application if you are performing an unload of IQ (use update) or a load to ASA (use migrate)</td>
	 *    </tr>
	 *    <tr>
	 *       <td>migrationPath</td>
	 *       <td>C:\\tmp</td>
	 *       <td>This is the location of the unloaded table files</td>
	 *    </tr>
	 *    <tr>
	 *       <td>LOG_DIR</td>
	 *       <td></td>
	 *       <td>This is the location of Log Directory.</td>
	 *    </tr>
	 * </tbody>
	 * </table>
	 * 
	 * @param args
	 */
	public static void main(final String[] args) {
		initLogger();
		Date d = new Date();
//		final String loadTableStatementsFileName = "loadTableStatements.sql";
		
		logger.info("Starting the Migration ("+d.toString()+")");
		
		//Upgrade and unload tables...
		try {
			initConnection();
			if(System.getProperty("migrationType", "update").equals("update")){
				//Unload all the tables from the old database (pre IQ15.2)
				unloadTables();
				//Generate the load statements for the new database, based on the column order for the old database.
				//This file is used in the migrate part of the upgrade (see below).
				generateLoadTableSQLStatementFile(loadTableStatementsFileName);
			}else if(System.getProperty("migrationType", "update").equals("migrate")){
				//Load tables using the loadTableStatement.sql, which was created in the update part of the upgrade (see above).
				loadTables(loadTableStatementsFileName);
				//Remove all files generated by this procedure.
				removeFiles(System.getProperty("migrationPath", "C:\\tmp"));
			}else{
				logger.severe("Incorrect migrationType specificied, must be either update (Unloading tables) or migrate (Loading Tables)");
			}
		} catch (MigrationException e) {
			logger.severe(e.getMessage());
			//Something went wrong, exit with a non zero value to indicate that the procedure failed.
			System.exit(1);
		} finally{
			try {
				closeConnection();
			} catch (MigrationException e) {
				logger.severe(e.getMessage());
			}
		}
		logger.info("Finished the Migration ("+new Date().toString()+")");
		//Nothing sent wrong, exit with a zero indicating all is OK.
		System.exit(0);
	}

	/**
	 * This method generates the load statements and saves them to a file.
	 * @throws MigrationException
	 */
	private static void generateLoadTableSQLStatementFile(final String loadTableStatementsFileName)
			throws MigrationException {
		List<String> tableLoadStatements = generateLoadTableStatements("SYS.SYSCOLUMNS", System.getProperty("migrationPath", "C:\\tmp"));
		generateLoadTableStatementFile(tableLoadStatements, loadTableStatementsFileName);
	}

	/**
	 * LOAD all tables(etlrep and dwhrep) from repdb.
	 * @throws MigrationException
	 */
	public static void loadTables(final String loadTableStatementsFileName) throws MigrationException{
		logger.entering("loadTables", "Loading Tables To SQL Anywhere repdb");
		final long startMilliseconds = System.currentTimeMillis();
		loadTables(System.getProperty("sqlQuery","sp_tables '%', '%rep', '%', \"'TABLE'\""), loadTableStatementsFileName);
		final long endMilliseconds = System.currentTimeMillis();
		logger.exiting("loadTables", "Finished Loading Tables To SQL Anywhere repdb in: "+((endMilliseconds - startMilliseconds)/1000)+"sec.");
	}

	/**
	 * UNLOAD all tables(etlrep and dwhrep) from repdb.
	 * @throws MigrationException
	 */
	public static void unloadTables() throws MigrationException{
		logger.entering("unloadTables", "Unloading Tables from Sybase IQ repdb");
		final long startMilliseconds = System.currentTimeMillis();
		unloadTables(System.getProperty("sqlQuery","sp_tables '%', '%rep', '%', \"'TABLE'\""));
		final long endMilliseconds = System.currentTimeMillis();
		logger.exiting("unloadTables", "Finished Unloading Tables from Sybase IQ repdb in: "+((endMilliseconds - startMilliseconds)/1000)+"sec.");

	}

	/**
	 * This method creates and executes statements to unload all the tables from the repdb.
	 * @param sqlQuery
	 * @param unload true=create UNLOAD TABLE statements.
	 * @throws MigrationException
	 */
	public static void unloadTables(final String sqlQuery) throws MigrationException {
		Statement statement      = null;
		Statement statementBatch = null;
		ResultSet repDBTables    = null;
		logger.entering("unloadloadTables", "SQL Query = "+sqlQuery);
		try {
			//01. Create the statement...
			statement   = connection.createStatement();
			
			//02. Execute the statement to get the list of tables (etlrep and dwhrep) in the repdb.
			repDBTables = statement.executeQuery(sqlQuery);
			
			//03. Create a new batch statement for executing the UNLOAD TABLE statements...
			statementBatch = connection.createStatement();
			
			//04. Iterate over each row returned and create an UNLOAD/LOAD TABLE statement for each
			logger.info("Building the Load or Unload table queries" );
			while(repDBTables.next()){
				if(repDBTables.getString("tname").equals("META_DATABASES"))
				{
					//Don't load or unload the META_DATABASES table. 
				}else{
					statementBatch.addBatch(createUnloadLoadTableSQL(repDBTables.getString("creator"), repDBTables.getString("tname"), System.getProperty("migrationPath", "C:\\tmp"), true));
					tableCount++; //the number of tables found in the repdb.
				}
			}
			
			//05. Execute the new batch statement...
			logger.info("About to execute the batch statement...");
			int[] result = statementBatch.executeBatch();
			logger.info(result.length+"/"+tableCount+" statements were executed successfully");
		} 
		catch (SQLException e) {
			throw new MigrationException(
					"ERROR: Migration failed", e);
		}finally{
			try {
				if(repDBTables != null){
					repDBTables.close();
				}
			} catch (SQLException e) {
				throw new MigrationException("WARNING: Cannot close ResultSet: ", e);
			}
			try {
				if(statement != null){
					statement.close();
				}
			} catch (SQLException e) {
				throw new MigrationException("WARNING: Cannot close Statement: ", e);
			}
			try {
				if(statementBatch != null){
					statementBatch.close();
				}
			} catch (SQLException e) {
				throw new MigrationException("WARNING: Cannot close BatchStatement: ", e);
			}
		}
	}

	/**
	 * This method creates and executes statements to unload/load all the tables from the repdb.
	 * @param sqlQuery
	 * @param unload true=create UNLOAD TABLE statements, false=create LOAD TABLE statements
	 * @throws MigrationException
	 */
	public static void loadTables(final String sqlQuery, final String loadTableStatementsFileName) throws MigrationException {
		Statement statementBatch = null;
		logger.entering("unloadloadTables", "SQL Query = "+sqlQuery);
		try {
			//01. Create a new batch statement for executing the UNLOAD TABLE statements...
			statementBatch = connection.createStatement();

			//02. Special handling for the files below.
			logger.info("Building the LOAD TABLE Statements");
			statementBatch.addBatch("TRUNCATE TABLE etlrep.META_CONNECTION_TYPES;");
			statementBatch.addBatch("TRUNCATE TABLE etlrep.META_VERSIONS;");

			//03. Read in the loadTableStatements file...
			List<String> loadTableStatements = extractGeneratedLoadTableStatements(loadTableStatementsFileName);
			Iterator<String> itr = loadTableStatements.iterator();
			while(itr.hasNext()){
				//06. Read each line and put it into the statementBatch...
				statementBatch.addBatch(itr.next());
			}

			//04. Execute the new batch statement...
			logger.info("About to execute the batch statement...");

			int[] result = statementBatch.executeBatch();
			logger.info(result.length+"/"+tableCount+" statements were executed successfully");
		} 
		catch (SQLException e) {
			throw new MigrationException(
					"ERROR: Migration failed", e);
		}finally{
			try {
				if(statementBatch != null){
					statementBatch.close();
				}
			} catch (SQLException e) {
				throw new MigrationException("WARNING: Cannot close BatchStatement: ", e);
			}
		}
	}


	/**
	 * Initialise the connection towards the database.
	 * @return
	 * @throws MigrationException
	 */
	public static Connection initConnection() throws MigrationException {
		try {
			final Driver driver = (Driver) Class.forName(driverName)
					.newInstance();
			final Properties properties = new Properties();
			properties.put("user", strUserName);
			properties.put("password", strPassword);
			if (dbType.equalsIgnoreCase("sybase")) {
				properties.put("REMOTEPWD", ",,CON=" + conName);
			}
			connection = driver.connect(dbURL, properties);
			if (connection == null) {
				throw new MigrationException(
						"ERROR: Initialise the connection. Couldn't connect to database with given URL="
								+ dbURL);
			}
			connection.setAutoCommit(autoCommit);

		} catch (InstantiationException e) {
			throw new MigrationException(
					"ERROR: Initialise the connection. Couldn't init the Class: "
							+ driverName, e);
		} catch (IllegalAccessException e) {
			throw new MigrationException(
					"ERROR: Initialise the connection. IllegalAccessException for the Class: "
							+ driverName, e);
		} catch (ClassNotFoundException e) {
			throw new MigrationException(
					"ERROR: Initialise the connection. Couldn't find the Class: "
							+ driverName, e);
		} catch (SQLException e) {
			throw new MigrationException(
					"ERROR: Initialise the connection. Couldn't connect to the database ("
							+ dbURL + "): ", e);
		}
		return connection;
	}

	/**
	 * Close the connection to the database.
	 * @throws MigrationException
	 */
	public static void closeConnection() throws MigrationException {
		try {
			connection.close();
		} catch (SQLException e) {
			throw new MigrationException("Coundn't close the connection towards the database!", e);
		}
	}

		
	/**
	 * Create the UNLOAD/LOAD TABLE SQL String.
	 * @param tableCreator dwhrep|etlrep
	 * @param tableName
	 * @param unload true=Create UNLOAD TABLE SQL, false = create LOAD TABLE SQL
	 * @return
	 */
	public static String createUnloadLoadTableSQL(final String tableCreator, final String tableName, final String targetPath, final boolean unload) {
		final StringBuffer sqlStatement = new StringBuffer();
		
		if(unload){
			sqlStatement.append(UNLOAD);
		}else{
			sqlStatement.append(LOAD);			
		}
		sqlStatement.append(tableCreator);
		sqlStatement.append('.');
		sqlStatement.append(tableName);
		
		if(unload){
			sqlStatement.append(TO);
		}else{
			sqlStatement.append(FROM);			
		}
		sqlStatement.append("'"); //NOPMD
		sqlStatement.append(targetPath);
		sqlStatement.append(System.getProperty("file.separator"));
		sqlStatement.append(tableCreator);
		sqlStatement.append('_');
		sqlStatement.append(tableName);
		sqlStatement.append(".txt';");
		logger.info("Adding: "+sqlStatement.toString());
		return sqlStatement.toString();
	}

	/**
	 * Execute a batch of statements.
	 * @param statement
	 * @throws MigrationException
	 */
	public void executeBatch(final Statement statement) throws MigrationException {
		try {
			int[] rows = statement.executeBatch();
			logger.info(rows.length+"/"+tableCount+" statements were executed successfully");
		} catch (SQLException e) {
			throw new MigrationException("ERROR: Executing Batch of Load/Unload statements", e);
		}
		
	}

	/**
	 * Remove all the unloaded table files from the target directory. 
	 * All files starting with dwhrep_ or etlrep_ and ending with .txt will be removed.
	 * @param directoryPath
	 * @throws MigrationException
	 */
	public static void removeFiles(final String directoryPath) throws MigrationException {
		logger.entering("removeFiles", "Removing all tables files from the following directory: "+directoryPath);
		int count = 0;
		//remove all files that start with dwhrep || etlrep && end with .txt in the directory, directoryPath.
		final FilenameFilter filter = new FilenameFilter(){
			public boolean accept(final File file, final String name){
				boolean isAccepted = false;
				if((name.startsWith("dwhrep_") || name.startsWith("etlrep_")) && name.endsWith(".txt")){
					isAccepted = true;
				}
				return isAccepted;
			}
		};
		
		final File directory = new File(directoryPath);
		final File[] filesToDelete = directory.listFiles(filter);
		for(File f: filesToDelete){
			f.delete();
			count++;
		}
		boolean success = new File(directoryPath + System.getProperty("file.separator") + loadTableStatementsFileName).delete();
		if(success){
			count++;
		}
		logger.exiting("removeFiles", "Removed "+count+" table file(s)");
	}

	/**
	 * This method queries the SYS.SYSCOLUMNS (sysTableName) table to get a list of the 
	 * columns for all the dwhrep and etlrep tables. It then creates a load statement for each table.
	 * i.e. load table dwhrep.Busyhour(VERSIONID,
	 * 								   BHLEVEL,
	 * 								   BHTYPE,
	 * 								   BHCRITERIA,
	 * 								   WHERECLAUSE,
	 * 								   DESCRIPTION,
	 * 								   TARGETVERSIONID,
	 * 								   BHOBJECT,
	 * 								   BHELEMENT,
	 * 								   ENABLE,
	 * 								   AGGREGATIONTYPE,
	 * 								   OFFSET,
	 * 								   WINDOWSIZE,
	 * 								   LOOKBACK,
	 * 								   P_THRESHOLD,
	 * 								   N_THRESHOLD,
	 * 								   CLAUSE,
	 * 								   PLACEHOLDERTYPE,
	 * 								   GROUPING,
	 * 								   REACTIVATEVIEWS) from '/eniq/.../dwhrep_Busyhour.txt';
	 * @param sysTableName
	 * @param targetPath
	 * @return
	 */
	private static List<String> generateLoadTableStatements(final String sysTableName, final String targetPath) throws MigrationException{
		List<String> loadStatements = new ArrayList<String>();
		
		//Create the SQL statement...
		StringBuffer buffer = new StringBuffer();	
		buffer.append("select * from ");
		buffer.append(sysTableName);
		buffer.append(" where creator like '%rep%' order by tname,colno;");
		
		Statement statement = null;
		ResultSet result    = null;

		try {
			statement    = connection.createStatement();
			result       = statement.executeQuery(buffer.toString());
			String key = "";
			StringBuffer value = new StringBuffer();
			String creator = "";
			String tableN1 = "";
			while(result.next()){
				tableN1 = result.getString("tname").trim();
				if(tableN1.equals("META_DATABASES")){
					//Don't create a load table statement for this table.
				}else if(tableN1.equals(key)){
					creator = result.getString("creator").trim();
					value.append(",");
					value.append(result.getString("cname").trim());
				}else{
					if(key.equals("")){
						creator = result.getString("creator").trim();
						key = tableN1;
						value.append("load table ");
						value.append(creator);
						value.append(".");
						value.append(tableN1);
						value.append("(");
						value.append(result.getString("cname").trim());
					}else{
						value.append(") from '");
						value.append(targetPath);
						value.append(System.getProperty("file.separator"));
						value.append(creator);
						value.append('_');
						value.append(key);
						value.append(".txt';");
						loadStatements.add(value.toString());
						value.delete(0,value.length());//Clear the StringBuffer.
						creator = result.getString("creator").trim();
						key = tableN1;
						value.append("load table ");
						value.append(creator);
						value.append(".");
						value.append(tableN1);
						value.append("(");
						value.append(result.getString("cname").trim());						
					}
				}
			}
			//Tidy up the last load statement...
			value.append(") from '");
						value.append(targetPath);
						value.append(System.getProperty("file.separator"));
						value.append(creator);
						value.append('_');
						value.append(key);
						value.append(".txt';");
			loadStatements.add(value.toString());
		} catch (SQLException e) {
			throw new MigrationException("ERROR: Failed to create LOAD TABLE statements. ", e);
		}
		return loadStatements;
	}
	
	/**
	 * Setup the logger.
	 */
	public static void initLogger() {
		String logDir = System.getProperty("LOG_DIR");
		logDir = logDir + System.getProperty("file.separator") + "migration";
		String logName = "migration.log";

		File logDirectory = new File(logDir);
		logDirectory.mkdir();	
		logDirectory.canWrite();
		
		File f = new File(logDir+System.getProperty("file.separator")+logName);
		f.canRead();
		f.canWrite();
		
		try {
			FileHandler fileHandler = new FileHandler(logDir+System.getProperty("file.separator")+logName);
			fileHandler.setFormatter(new SimpleFormatter());
			logger.addHandler(fileHandler);
			logger.setLevel(Level.ALL);
		} catch (SecurityException e) {
			logger.severe(e.getMessage());
		} catch (IOException e) {
			logger.severe(e.getMessage());
		}
	}

	/**
	 * This method writes all the load table statements to a file (fileName). The file is written to the migrationPath.
	 *   
	 * @param tableLoadStatements
	 * @param fileName
	 * @throws MigrationException
	 */
	public static void generateLoadTableStatementFile(
			final List<String> tableLoadStatements, final String fileName) throws MigrationException {
		if(tableLoadStatements == null){
			throw new MigrationException("ERROR: No load table statements were found.");
		}
		if(fileName == null){
			throw new MigrationException("ERROR: No file name provided.");
		}

		StringBuffer filePath = new StringBuffer();
		try {
			filePath = new StringBuffer();
			filePath.append(System.getProperty("migrationPath", "C:\\tmp"));
			File file = new File(filePath.toString());
			if(!file.exists()){
				file.mkdir();
			}
			filePath.append(System.getProperty("file.separator"));
			filePath.append(fileName);

			PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(filePath.toString())));
			Iterator<String> itr = tableLoadStatements.iterator();

			while(itr.hasNext()){
				out.print(itr.next());
				out.println();
			}
			out.close();
		} catch (IOException e) {
			throw new MigrationException("ERROR: Failed to write the load table statements file: "+filePath.toString(), e);
		}

	}

	/**
	 * This method extracts the load table statements from the SQL file.
	 * @param loadTableStatementsFileName
	 * @return
	 * @throws MigrationException
	 */
	public static List<String> extractGeneratedLoadTableStatements(
			String loadTableStatementsFileName) throws MigrationException {

		List<String> extractedLoadTableStatements = new ArrayList<String>();
		StringBuffer filePath = new StringBuffer();
		filePath.append(System.getProperty("migrationPath", "C:\\tmp"));
		filePath.append(System.getProperty("file.separator"));
		filePath.append(loadTableStatementsFileName);

		BufferedReader in = null;
		try {
			in = new BufferedReader(new FileReader(filePath.toString()));
			String line = null;

			while (( line = in.readLine()) != null){
				extractedLoadTableStatements.add(line);
			}
			in.close();
		} catch (FileNotFoundException e) {
			throw new MigrationException("ERROR: Failed to find the LOAD TABLE Statements file: "+filePath.toString(), e);
		} catch (IOException e) {
			throw new MigrationException("ERROR: IOException while reading: "+filePath.toString(), e);
		}

		return extractedLoadTableStatements;
	}
}